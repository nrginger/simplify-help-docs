import os
import time
import pandas as pd
import requests
from dotenv import load_dotenv
from tqdm import tqdm
import openpyxl
from openpyxl.styles import Alignment
import re

# Загрузка переменных окружения
load_dotenv()
API_KEY = os.getenv("API_KEY")

# Конфигурация API
BASE_URL = 'https://api.aitunnel.ru/v1/chat/completions'
HEADERS = {
    'Content-Type': 'application/json',
    'Authorization': f'Bearer {API_KEY}'
}


def format_excel(file_path):
    """
    Применяет форматирование к Excel-файлу для лучшей читаемости.

    Args:
        file_path (str): Путь к Excel-файлу
    """
    wb = openpyxl.load_workbook(file_path)
    ws = wb.active

    for row in ws.iter_rows():
        for cell in row:
            cell.alignment = Alignment(
                wrap_text=True,
                vertical='top',
                horizontal='left'
            )

    for column in ws.columns:
        column_letter = column[0].column_letter
        ws.column_dimensions[column_letter].width = 80

    wb.save(file_path)
    print(f"Файл {file_path} отформатирован")


def main():
    # Пути к файлам
    input_file = "unique_texts_200_formatted.xlsx"

    # Чтение Excel-файла
    print(f"Чтение файла {input_file}...")
    df = pd.read_excel(input_file)

    # Проверка существования столбца unique_text
    if 'unique_text' not in df.columns:
        print("Ошибка: В файле нет столбца 'unique_text'")
        return

    # Создаем столбец для золотого стандарта, если его еще нет
    if 'golden_standard' not in df.columns:
        df['golden_standard'] = None

    # Обрабатываем тексты группами по 10
    batch_size = 10

    # Определяем общее количество групп
    total_batches = (len(df) + batch_size - 1) // batch_size

    for batch_idx in range(total_batches):
        start_idx = batch_idx * batch_size
        end_idx = min(start_idx + batch_size, len(df))

        print(f"Обработка группы {batch_idx + 1}/{total_batches} (тексты {start_idx} - {end_idx - 1})")

        # Проверяем, есть ли необработанные тексты в этой группе
        unprocessed_indices = [idx for idx in range(start_idx, end_idx)
                               if pd.isna(df.at[idx, 'golden_standard'])]

        if not unprocessed_indices:
            print(f"Группа {batch_idx + 1} уже полностью обработана, пропускаем")
            continue

        # Формируем групповой промпт только для необработанных текстов
        batch_prompt = """Ты - опытный технический писатель. Твоя специализация — улучшение пользовательской документации и руководств пользователя на русском языке. Ты придерживаешься легкого инфостиля - информационного стиля. Тебя вдохновляют взгляды и работы Максима Ильяхова и Норы Галь - книга "Слово живое и мертвое". Выполняй правила ниже.
Попутно исправляй ошибки, которые возникли в результате распознавания PDF в TXT.

##Правила##
1. Делай:
   - Переписывай текст так, чтобы он стал простым и легким для восприятия.
   - Сохраняй технические термины и названия брендов без изменений.
   - Разделяй большие предложения на более короткие и четкие.
   - Заменяй причастия на конструкции "который + глагол", например "параметры, сохраняемые в памяти" --> "параметры, которые сохраняются в памяти".
   - Переделывай деепричастные обороты в новое предложение.
   - Обращайся к пользователю напрямую, используя "вы".
   - Применяй активный залог и добавляй больше глаголов для ясности.
   - Где возможно – заменяй существительные глаголами.
   - Соблюдай доброжелательный и поддерживающий tone of voice.
   - Если встречаешь символы, которые не имеют значения и не подходят по контексту – удаляй их.
   - Если видишь пробелы между словами, которых быть не должно – убирай пробелы.
   - Если в словах есть дефисы, которых быть не должно – убирай дефисы.
2. НЕ делай:
   - НЕ используй канцеляризмы, клише и манипулятивные фразы.
   - НЕ используй причастные и деепричастные обороты.
   - НЕ используй скобки и сложные синтаксические конструкции.
   - НЕ используй модальные слова, такие как "нужно", "можно", "необходимо", "следует" и другие подобные слова.
   - НЕ используй слова "данный" и "следующий", заменяй на конкретные указательные местоимения, например "этот", если они нужны.
   - НЕ используй слово "является", заменяй его на тире.
   - НЕ используй пассивные формы — выбирай активные и прямые конструкции.

##КОНТЕКСТ##
Тебе даны отрывки технической документации, которые нужно переработать в легкий и понятный стиль. Этот стиль должен соответствовать стандартам документации таких компаний, как Яндекс, Microsoft, Apple, Google. Тексты должны быть ясными и четкими, оставаясь в рамках технического домена, без перехода в разговорный стиль. Образцы переписанных фраз:
- Пример: "для настройки питания блока" --> "чтобы настроить питание блока".
- Пример: "Регулировка и настройка двигателя" --> "Как отрегулировать и настроить двигатель"
- Пример: "Выполните это для каждого устройства, изменяя положение переключателей согласно таблице." --> "Выполните это для каждого устройства. Изменяйте положение переключателей по таблице."
- Пример: "деталь является частью прибора" --> "деталь - это часть прибора"
- Пример: "связь, устанавливаемая" --> "связь, которая устанавливается"
- Пример: "при наличии заслонки" --> "если есть заслонка"
- Пример: "при эксплуатации холодильника" --> "когд вы используете холодильник"
- Пример: "производить проверку" --> "проверять"
- Пример: "осуществлять контроль" --> "контролировать"
- Пример: "выполнять работу" --> "работать"
- Пример: "совершать покупку" --> "покупать"
- Пример: "до момента открытия" --> "до того, как откроется"
Также учитывай, что инструкции были распознаны из PDF, поэтому они могут содержать артефакты: лишние символы, знаки препинания, неправильно распознанные слова. Исправляй такие недочеты.
Следуй этим инструкциям для достижения наиболее точного и эффективного результата. 
Для каждого текста напиши только упрощенную версию, без дополнительных комментариев.
Чётко отделяй тексты друг от друга с помощью маркера [ТЕКСТ X], где X - номер текста.

Вот тексты для упрощения:
"""

        # Добавляем только необработанные тексты в группе к промпту
        for i, idx in enumerate(unprocessed_indices):
            batch_prompt += f"\n[ТЕКСТ {i + 1}]\n{df.at[idx, 'unique_text']}\n"

        # Выполняем один запрос к API для всей группы
        payload = {
            "model": "claude-3.7-sonnet",
            "messages": [
                {
                    "role": "user",
                    "content": batch_prompt
                }
            ],
            "temperature": 0.7,
            "max_tokens": 4000
        }

        try:
            print(f"Отправка запроса для группы {batch_idx + 1}...")
            response = requests.post(BASE_URL, headers=HEADERS, json=payload)
            response.raise_for_status()

            simplified_batch = response.json()['choices'][0]['message']['content']

            # Разбираем ответ на отдельные тексты по маркерам [ТЕКСТ X]
            text_blocks = re.split(r'\[ТЕКСТ \d+\]\n?', simplified_batch)

            # Убираем пустой первый элемент, если он есть
            if text_blocks and not text_blocks[0].strip():
                text_blocks = text_blocks[1:]

            # Распределяем результаты по соответствующим строкам
            for i, idx in enumerate(unprocessed_indices):
                if i < len(text_blocks):
                    df.at[idx, 'golden_standard'] = text_blocks[i].strip()
                else:
                    print(f"Предупреждение: не получен ответ для текста {idx}")

            # Сохраняем после каждой группы
            print(f"Сохранение результатов после группы {batch_idx + 1}...")
            df.to_excel(input_file, index=False)
            format_excel(input_file)

        except Exception as e:
            print(f"Ошибка при обработке группы {batch_idx + 1}: {str(e)}")
            if hasattr(e, 'response') and e.response:
                print(f"Статус: {e.response.status_code}")
                print(f"Ответ: {e.response.text}")

            # Сохраняем то, что успели обработать
            df.to_excel(input_file, index=False)
            format_excel(input_file)

        # Пауза между группами
        time.sleep(3)

if __name__ == "__main__":
    main()